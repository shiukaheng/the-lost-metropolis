# Todo
- Seperate this into multiple smaller repositories
    - vapor-types: all the types / schemas shared across the platform
    - vapor-api: api for javascript clients to interact with the backend
    - the-lost-metropolis: monorepo for firebase web app and cloud functions (both consumes vapor types, only web app consumes vapor-api)
    - vapor-uploader: electron app to convert / create assets and upload to the server

- Create asset uploading client
- Make assets renameable and identifiable by ID -> Improve Assets schema and unify for frontend and backend
- Make .vaps format support multiple assets within one file

# Creating new types

## Asset types

Asset types (e.g. Potree2) are format specifications for a collection of files that are used, along with some metadata, to create a single asset. The client can retrieve the asset's root directory from the API, and the references for files inside the asset root should either be already known / constant or specified in the metadata.

- To create a new asset type:
  - Create a new file in /functions/src/lib/types/asset_types for the cloud function to know how to handle the asset type
  - Include this new class in /function/src/lib/types/AssetType.ts
  - Update the sourceAssetLiteral / targetAssetLiteral definintions in /api/types/AssetLiteral.ts to include the new asset type
  - Update /functions/src/lib/types/AssetType.ts to include the new asset type
- To use assets as an argument in VaporComponents
  - Create a entry in the input property in the following format:
    {VaporComponent}.inputs = {
    ...genericInputs,
    {someAsset}: {
    type: createAssetType([{List of accepted asset types}]),
    default: null
    },
    ...
    }
    Once the input is set, the asset will be supplied as a prop in the format of a ClientAsset, and to get the baseUrl, you need to use VaporAPI.resolveAsset(postID, assetID)

## VaporComponents

VaporComponent types are special 3D components that have extra logic that allows it to be recognized in the Editor and allows prop editing

- To create a new VaporComponent:
  - Create a new file in /src/components/3d
  - After the function definition, be sure to add the following extra properties to the function:
    - displayName: The component type name displayed in the editor
    - componentType: An identifying string for the component type
    - inputs: An object describing the inputs to the component, including the type and default values; read by the Editor
  - Update /api/types/ComponentLiterals.ts to include the new componentType string
  - Add the component to the "components" export in src/components/viewer/ComponentDeclarations.tsx


## Process of uploading Assets
- A default asset object is created using assetSchema.default() with an uuid generated by the client
- The client then uploads a file to the default bucket, it could either be a .vaps package, or a standalone file depending on the upload method used. 
  - In the case of a .vaps package, its root folder contains a metadata.json that specifies asset details, and a data folder which stores all the files required by the asset.
  - For single file uploads, since no metadata.json can be provided, you need to either supply it as an object for as a function argument, or if no argument was given, the cloud function will try and infer it.
- A cloud function will then be triggered when the file is uploaded (which will mark the asset's pending property as false), and convert the asset if needed (during conversion, updates the asset processProgress property, and when finished, updates the asset processed property to true), and finally upload it to the static server (and marks the asset ready property as true).

# Improvements

- Currently ViewerContext and EditorContext are just one big object with unrelated functionality, and some setValue functions are even passed down, causing some infinite rendering loop issues if setting of one property affects the value of another. Should seperate these into different contexts, but the reason why I initially structured like this is for ease of use. Perhaps find a state management library to improve this? Using useLazyEffect custom hook to get around this but is incredibly hacky. Basically does deep check of dependencyArray to see if the value has actually changed, and only actually call the callback if it did change. Will have impact on performance since these comparisons are not cheap if the dependencies are complex.

- Refactor React components to be more readable