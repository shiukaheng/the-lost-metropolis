# Todo

## Urgent

## Non-urgent

- Seperate this into multiple smaller repositories
    - vapor-types: all the types / schemas shared across the platform
    - vapor-api: api for javascript clients to interact with the backend
    - the-lost-metropolis: monorepo for firebase web app and cloud functions (both consumes vapor types, only web app consumes vapor-api)
    - vapor-uploader: electron app to convert / create assets and upload to the server

- Create asset uploading client
- Make assets renameable and identifiable by ID -> Improve Assets schema and unify for frontend and backend
- Make .vaps format support multiple assets within one file
- Change transformation gizmo from constantly updating transformation props to imperatively updating a transformAnimationGroup injected into scene graph to reduce the number of updates
- Background image uploading function broken when filename has special characters like "-"
- Improve editor UX, right now it is ambiguous whether the action is instantly updated or reuqires "update"
- Find a way to cull unreferenced assets
- Finalize VaporComponents to all use assets system


# Asset types

Asset types (e.g. Potree2) are format specifications for a collection of files that are used, along with some metadata, to create a single asset. The client can retrieve the asset's root directory from the API, and the references for files inside the asset root should either be already known / constant or specified in the metadata.

- To create a new asset type:
  - Create a new file in /functions/src/lib/types/asset_types for the cloud function to know how to handle the asset type
  - Include this new class in /function/src/lib/types/AssetType.ts
  - Update the sourceAssetLiteral / targetAssetLiteral definintions in /api/types/AssetLiteral.ts to include the new asset type
  - Update /functions/src/lib/types/AssetType.ts to include the new asset type
- To use assets as an argument in VaporComponents
  - Create a entry in the input property in the following format:
    {VaporComponent}.inputs = {
    ...genericInputs,
    {someAsset}: {
    type: createAssetType([{List of accepted asset types}]),
    default: null
    },
    ...
    }
    Once the input is set, the asset will be supplied as a prop in the format of a ClientAsset, and to get the baseUrl, you need to use VaporAPI.resolveAsset(postID, assetID)

# VaporComponents

VaporComponent types are special 3D components that have extra logic that allows it to be recognized in the Editor and allows prop editing

- To create a new VaporComponent:
  - Create a new file in /src/components/3d
  - After the function definition, be sure to add the following extra properties to the function:
    - displayName: The component type name displayed in the editor
    - componentType: An identifying string for the component type
    - inputs: An object describing the inputs to the component, including the type and default values; read by the Editor
  - Update /api/types/ComponentLiterals.ts to include the new componentType string
  - Add the component to the "components" export in src/components/viewer/ComponentDeclarations.tsx

# EditorInputTypes

EditorInputTypes are not actually typescript types, but are objects attached to VaporComponents to describe and check the schema of input props. Most importantly, it allows the Editor to display the correct input fields for each component type.

Each type consists of the following:
- typeName: a unique string identifier for the type of input
- typeCheck: a predicate function that returns true if the input is of the correct type
- data (optional): an object containing additional data that is used by to modify behaviour of the input component, this may be supplied during the definition of a VaporComponent, or during runtime by the Editor

The values of all input types has to be JSON-serializable, but other than that, there are no limitations as the values are stored as is in the database.
The backend has no idea what the input type is and does not enforce any type checking, the types are entirely for the Editor to use and supplied directly to VaporComponents.

Note: Perhaps it would be better to make the naming more consistent, and eliminating the name "ArgumentType" in favor of "EditorInputType"

## To add a new input type:
- Create a new object in src\components\viewer\ArgumentTypes.tsx, and include it in the file's ArgumnetLiteral type.
- Alternatively, you can create input types dynamically by creating a function that returns a new EditorInputType, and call that function when creating a VaporComponent. It would be recognized by the Editor as long as the typeName exists in the ArgumentLiteral type.
- Create a new Input component in src\components\utilities\Input.tsx and add an entry to InputComponentMap in the same file to map the typeName to the component.

# Process of uploading Assets
- A default asset object is created using assetSchema.default() with an uuid generated by the client
- The client then uploads a file to the default bucket, it could either be a .vaps package, or a standalone file depending on the upload method used. 
  - In the case of a .vaps package, its root folder contains a metadata.json that specifies asset details, and a data folder which stores all the files required by the asset.
  - For single file uploads, since no metadata.json can be provided, you need to either supply it as an object for as a function argument, or if no argument was given, the cloud function will try and infer it.
- A cloud function will then be triggered when the file is uploaded (which will mark the asset's pending property as false), and convert the asset if needed (during conversion, updates the asset processProgress property, and when finished, updates the asset processed property to true), and finally upload it to the static server (and marks the asset ready property as true).

# Updating post schema
- Remember to update both Post and PostDocData schemas
- Also, update importPost and exportPost in the api

# Viewer
- The viewer is a bungled chunk of mess that needs to be refactored.. but essentially, it is a container for 3D components and performs two roles:
  - Allows imperative changes to the child 3D components (adding them, modifying them, removing them) during runtime - allows for programmatic creation of components
  - Provides runtime parameters and references as context, and allow modification during rendering (e.g. camera position, positional audio listener, etc)
- The component is further broken down into two parts:
  - The ViewerManager component, which manages the state variables and the child components
  - The ViewerUI component, which outputs the DOM elements for actually viewing the components
    - The ViewerUI is minimal, and does not contain any game controls, which can be supplied by child components.
  - This architecture is designed so that mutations of the Viewer can be easily made with extra state variables and display of 3d components by sandwiching extra logic between the two components.
  - Alternatively, the ViewerUI can be swapped out entirely, as it is done in Editor.
  - So in a sense ViewerManager is the core of all the 3D experiences in Vapor.
- The overarching problem is that all the variables and setters are passed by a single context object, and so when any of the variables change, the entire state of the viewer is changed, leading to a lot of unnecessary re-renders. This should be fixed to use a proper state management system, I am eyeing zustand for this.
- Moreover, the code on managing the context variables should be compartmentalized into individual hooks for easier management.

# Viewport
- The Viewport is a component used to render the 3D components, it is expected to be used by all 3D viewers since it performs a few essential roles:
  - Manages the ErrorBoundary so any errors in the 3D components are caught and displayed in the Viewport.
  - Uses ViewPort canvas, intercepts three.js runtime variables and passes them to the ViewportManager component.

# Editor (Referring to the 3D editor component)
- The Editor is a mutated Viewer component that serves as a visual interface for editing the 3D components.
- The extra state and references are mostly for managing the UI of the editor, and the actual editing of the components is done by the Viewer component.

# Implementation of scene interactions
Scene interaction is particularly challenging for this project, because the same scene needs to be consumed on normal desktop devices, VR headsets, and on mobile phones via AR, and how the user interacts with the objects will vary depending on each type of viewing experience (i.e., mouse clicking for desktop, tapping screen on phones, controllers on headsets). A naive approach would be to have each type of object / interaction add their own listeners to create the behaviour, but because our project does not required a wide range of user interactions (no grabbing, no advanced game mechanics), we decided to unify the interactions in the following categories for desktop, VR, and AR respectively:

Mouse crosshair hover, controller pointer hover, AR crosshair hover

# Implementation of locomotion
TBD

# Layers
- 0: Default layer, this is the only layer that will be rendered by default.
- 1, 2: Reserved for WebXR
- 3: Teleportation effectors, used for raycasting and finding teleportation targets, mesh basic material can be used to render the effectors for debugging.
- 4: Interactive effectors, used for raycasting and finding interactive objects - Not implemented yet
- 5: Editor layer, used for rendering the editor UI (i.e., gizmos)

# Teleportation raycasting
Raycasting is used in Vapor mainly for finding the floor for locomotion and interacting with objects. However due to the use of massive models, it may become infeasible to raycast some larger models. It is important we consider which models are too big for raycasting, and move these objects to a different layer so they are not raycasted. If we do still want to raycast them, we can consider using a simplified mesh to do the raycasting instead.

To allow for a smooth transition for adopting raycasting, the raycaster will cast on a different layer, so only objects that have been opted into raycasting will be raycasted and old components not updated to use this system will not be affected.

To create VaporComponents that will affect teleportation, we will follow the convention of merging the component prop with the TeleportTargetComponentProps type, which adds a teleportEffect prop to the component, which controls how the object will be affected by teleportation. "target" will make the object an teleportation target, "blocker" will block teleportation beams, and "bypass" makes it transparent to teleportation.

For each component we will have to manually implement using the teleportEffect prop, since some components may have subcomponents that need to be raycasted. For components / subcomponents that follow the convention, the objects will need to have the following properties set:
- "target" objects:
  - userData.teleportEffect will be set to "target"
  - layers.enable(3) will be called
- "blocker" objects:
  - userData.teleportEffect will be set to "blocker"
  - layers.enable(3) will be called
- "bypass" objects:
  - userData.teleportEffect will be set to undefined
  - layers.disable(3) will be called

For convenience, you can call each descendant with the applyTeleportationTargetEffect function.

# Improvements

- Currently ViewerContext and EditorContext are just one big object with unrelated functionality, and some setValue functions are even passed down, causing some infinite rendering loop issues if setting of one property affects the value of another. Should seperate these into different contexts, but the reason why I initially structured like this is for ease of use. Perhaps find a state management library to improve this? Using useLazyEffect custom hook to get around this but is incredibly hacky. Basically does deep check of dependencyArray to see if the value has actually changed, and only actually call the callback if it did change. Will have impact on performance since these comparisons are not cheap if the dependencies are complex.

- Refactor React components to be more readable